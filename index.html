<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>OtOjs · 解密前端（后台恢复 + 智能解密）</title>
<style>
  :root{
    --bg:#0b0f14;--card:#0f1621;--muted:#9db1c7;--line:#1f2937;--line2:#223046;
    --text:#e6eef7;--btn:#152033;--ok:#10b981;--warn:#f59e0b;--err:#ef4444;--link:#67e8f9;
    --accent:#3b82f6;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:var(--text)}
  a{color:var(--link)}
  .wrap{max-width:960px;margin:0 auto;padding:18px 14px 80px}
  h1{margin:10px 0 6px;font-size:20px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:12px;margin:10px 0}
  label{font-size:12px;color:var(--muted);margin-right:6px}
  input,select,textarea{width:100%;background:#0f1a2b;color:var(--text);border:1px solid var(--line2);border-radius:10px;padding:10px;font-size:13px}
  textarea{min-height:160px;font-family:ui-monospace,Consolas,Menlo,monospace}
  .row{display:flex;gap:8px;flex-wrap:wrap;margin:6px 0}
  .row>*{flex:1 1 200px}
  button{padding:10px 12px;border-radius:10px;border:1px solid #2b3b54;background:var(--btn);color:var(--text);cursor:pointer;font-weight:600}
  button.ok{border-color:var(--ok)}
  button.warn{border-color:var(--warn)}
  button.err{border-color:var(--err)}
  pre{white-space:pre-wrap;background:#0b1020;border:1px solid var(--line2);border-radius:10px;padding:10px;font-size:12px;max-height:380px;overflow:auto}
  small{color:var(--muted)}
  .bar-wrap{height:6px;background:#0b1020;border:1px solid var(--line2);border-radius:8px;overflow:hidden;margin-top:6px}
  .bar{height:100%;width:0%;background:var(--accent);transition:width 5s linear}
  .pill{display:inline-flex;gap:8px;align-items:center;border:1px solid var(--line2);border-radius:999px;padding:6px 10px;background:#0b1020}
  .hint{font-size:12px;color:var(--muted)}

  /* 一排小按钮（文件 / 远程 / 粘贴 / 格式 / 清空） */
  .btnbar{
    display:grid; grid-template-columns:repeat(5,1fr);
    gap:6px; margin-top:8px; position:relative; z-index:1;
  }
  .btncard{
    min-width:0; padding:10px 6px; border-radius:10px;
    background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.18); color:#fff;
    display:flex; flex-direction:column; align-items:center; justify-content:center;
    cursor:pointer; transition:transform .15s,background .15s,box-shadow .15s;
  }
  .btncard:hover{background:rgba(255,255,255,.12); transform:translateY(-1px); box-shadow:0 3px 8px rgba(0,0,0,.2)}
  .btnicon{font-size:16px}
  .btntxt{font-size:11px; font-weight:600; margin-top:2px}

  /* 远程弹窗（悬浮） */
  .remote-pop{
    position:fixed; left:0; top:0; width:min(92vw,360px);
    background:#0f1621; border:1px solid var(--line2); border-radius:12px;
    padding:10px; box-shadow:0 12px 28px rgba(0,0,0,.35);
    display:none; z-index:9999;
  }
  .remote-pop.show{display:block;}
  .remote-pop .pop-row{display:flex; gap:8px; margin-top:6px}
  .remote-pop input[type="url"]{
    flex:1 1 auto; min-width:0; background:#0f1a2b; border:1px solid var(--line2);
    border-radius:10px; padding:10px; color:var(--text); font-size:13px;
  }
  .remote-pop .pop-btn{ white-space:nowrap; padding:8px 12px; border-radius:10px; border:1px solid #2b3b54; background:var(--btn); color:var(--text) }
  .remote-pop .pop-btn.ok{ border-color:var(--ok) }
  .remote-pop .pop-btn.cancel{ border-color:var(--err) }

  /* 折叠的高级设置 */
  details.setting{ margin-top:8px }
  details.setting summary{ cursor:pointer; color:var(--muted); user-select:none }
  details.setting summary::-webkit-details-marker{ display:none }
  details.setting summary::before{ content:"▸ "; }
  details.setting[open] summary::before{ content:"▾ "; }
</style>
</head>
<body>
<div class="wrap">
  <h1>OtOjs · 解密前端</h1>

  <div class="card">
    <!-- 全部搬进高级设置 -->
    <details class="setting">
      <summary>高级设置</summary>
      <div class="row" style="margin-top:8px">
        <div><label>REPO</label><input id="repo" value="Mikephie/OtOjs" /></div>
        <div><label>BRANCH</label><input id="branch" value="main" /></div>
        <div><label>Token（contents:rw）</label><input id="token" type="password" placeholder="ghp_..." /></div>
      </div>
      <div class="row">
        <div><label>input.js 路径</label><input id="pathIn" value="input.js" /></div>
        <div><label>提交信息</label><input id="commitMsg" value="update: input.js via UI" /></div>
        <div>
          <label>要拉取哪个输出文件？</label>
          <select id="whichOut">
            <option value="output/output.js">第①次产物：output/output.js</option>
            <option value="output/output.deob2.js">第②次产物：output/output.deob2.js</option>
          </select>
        </div>
      </div>
      <div class="row">
        <div><label>轮询间隔（秒）</label><input id="pollSec" type="number" value="5" /></div>
        <div><label>最大等待（秒）</label><input id="maxWait" type="number" value="150" /></div>
        <div class="pill" title="前端将自动尝试 Packer/Eval/AADecode 解密">
          <input id="autoSmart" type="checkbox" checked /> <span>自动智能解密</span>
        </div>
      </div>
      <div class="pill" style="margin-top:6px">
        <input id="autoResume" type="checkbox" checked />
        <span>提交后允许后台执行，回到页面自动拉取</span>
      </div>
    </details>
    <div class="hint">提交后可后台执行；页面回到前台会自动恢复拉取并尝试本地智能解密。</div>
  </div>

  <div class="card">
    <small>把待解密脚本放到 <b>input.js</b> → 工作流自动跑 → 本地自动识别是否能前端解密</small>

    <!-- 隐藏文件 input -->
    <input type="file" id="file" accept=".js,.txt,.json" hidden />

    <!-- 小按钮区 -->
    <div class="btnbar">
      <label for="file" class="btncard"><span class="btnicon">📁</span><span class="btntxt">文件</span></label>
      <div class="btncard" id="btn-remote"><span class="btnicon">🌐</span><span class="btntxt">远程</span></div>
      <button class="btncard" id="btn-paste" type="button"><span class="btnicon">📋</span><span class="btntxt">粘贴</span></button>
      <button class="btncard" id="btn-clean" type="button"><span class="btnicon">🧹</span><span class="btntxt">格式</span></button>
      <button class="btncard" id="btn-clear" type="button"><span class="btnicon">🗑️</span><span class="btntxt">清空</span></button>
    </div>

    <!-- 远程弹窗 -->
    <div class="remote-pop" id="remote-pop">
      <input id="remoteUrlInline" type="url" placeholder="https:// 原始脚本 URL（支持 github/blob → raw）" />
      <div class="pop-row">
        <button class="pop-btn ok" id="remote-confirm">拉取</button>
        <button class="pop-btn cancel" id="remote-cancel">取消</button>
      </div>
    </div>
    <input id="remoteUrl" type="url" style="display:none" />

    <textarea id="codeIn" placeholder="把待解密的 JS 粘贴到这里，或用上方导入"></textarea>

    <div class="row">
      <button class="ok" onclick="submitInput()">① 提交到 input.js (PUT)</button>
      <button class="warn" onclick="startAutoPoll()">② 开始自动轮询（根据选择的输出文件）</button>
      <button onclick="beautify()">（可选）结果美化</button>
      <button onclick="copySel('#codeOut', this)">复制结果</button>
      <button class="err" onclick="clrAll()">清空输入与结果</button>
    </div>

    <div id="status"><small>状态：就绪</small></div>
    <div class="bar-wrap" id="barWrap" style="display:none"><div class="bar" id="bar"></div></div>
    <pre id="codeOut" placeholder="结果将显示在这里"></pre>
  </div>

  <div class="card">
    <div class="row">
      <div class="pill">
        <span>快速拉取 Raw：</span>
        <button onclick="loadOutputRaw('output/output.js')">output/output.js</button>
        <button onclick="loadOutputRaw('output/output.deob2.js')">output/output.deob2.js</button>
      </div>
      <button onclick="copySel('#outputRaw', this)">复制</button>
      <button onclick="downloadOutput()">下载当前结果</button>
    </div>
    <pre id="outputRaw"></pre>
  </div>
</div>

<script>
/* ====== 基础工具 & 状态栏 ====== */
const $=s=>document.querySelector(s);
function setStatus(msg){ $('#status').innerHTML = '<small>状态：'+ msg +'</small>'; }
function showBar(){ $('#barWrap').style.display='block'; const b=$('#bar'); b.style.transition='none'; b.style.width='0%'; void b.offsetWidth; b.style.transition='width 5s linear'; b.style.background='var(--accent)'; setTimeout(()=>b.style.width='100%',50); }
function okBar(){ $('#bar').style.background='var(--ok)'; }
function warnBar(){ $('#bar').style.background='var(--warn)'; }
function hideBar(){ $('#barWrap').style.display='none'; }
function ghHeaders(){ const t=$('#token').value.trim(); if(!t){ throw new Error('缺少 Token（需要 contents: read & write）'); } return {'Authorization':'Bearer '+t,'Accept':'application/vnd.github+json','If-None-Match':''}; }
function repoBase(){ return `https://api.github.com/repos/${$('#repo').value.trim()}` }
function nowTs(){ return Date.now().toString() }
</script>

<script>
/* ====== 文件导入 / 远程 / 粘贴 / 清空 / 美化 ====== */
$('#file').addEventListener('change', async (e)=>{ const f=e.target.files?.[0]; if(!f) return; const txt=await f.text(); $('#codeIn').value=txt; setStatus('已载入本地文件：'+f.name+' · '+txt.length+' 字符'); trySmartDecodeAndShow(txt,'输入'); });

async function loadRemote(){
  let u=$('#remoteUrl').value.trim(); if(!u){ setStatus('请输入 URL'); return }
  if(/https?:\/\/github\.com\/.+\/blob\//.test(u)){ u=u.replace('https://github.com/','https://raw.githubusercontent.com/').replace('/blob/','/'); }
  try{ const r=await fetch(u+'?t='+nowTs(),{cache:'no-store'}); const t=await r.text(); if(!r.ok) throw new Error(r.status+' '+r.statusText+' '+t.slice(0,200)); $('#codeIn').value=t; setStatus('远程已加载 · '+t.length+' 字符'); trySmartDecodeAndShow(t,'输入'); }catch(e){ setStatus('远程加载失败：'+e.message); }
}
async function pasteFromClipboard(){ try{ const t=await navigator.clipboard.readText(); $('#codeIn').value=t; setStatus('已从剪贴板粘贴 · '+t.length+' 字符'); trySmartDecodeAndShow(t,'输入'); }catch(e){ setStatus('粘贴失败：'+e.message); } }
function clrIn(){ $('#codeIn').value=''; setStatus('已清空输入'); }
function clrAll(){ $('#codeIn').value=''; $('#codeOut').textContent=''; $('#outputRaw').textContent=''; hideBar(); setStatus('已清空输入与结果'); }
async function ensurePrettier(){ if(window.prettier&&window.prettierPlugins&&window.prettierPlugins.babel) return; const s1=document.createElement('script'); s1.src='https://unpkg.com/prettier@3.2.5/standalone.js'; const s2=document.createElement('script'); s2.src='https://unpkg.com/prettier@3.2.5/plugins/babel.js'; document.body.appendChild(s1); await new Promise(r=>s1.onload=r); document.body.appendChild(s2); await new Promise(r=>s2.onload=r); }
async function beautify(){ let s=$('#codeOut').textContent||$('#codeIn').value||''; if(!s){ setStatus('无待美化内容'); return } try{ await ensurePrettier(); const out=prettier.format(s,{parser:'babel',plugins:[prettierPlugins.babel]}); $('#codeOut').textContent=out; setStatus('已用 Prettier 美化'); }catch(e){ setStatus('Prettier 失败：'+e.message); } }
async function copySel(sel,btn){ try{ const el=$(sel); const t=el?(el.value??el.textContent??''):''; await navigator.clipboard.writeText(t); const old=btn.textContent; btn.textContent='✅ 已复制'; setTimeout(()=>btn.textContent=old,1200);}catch(e){ setStatus('复制失败：'+e.message); } }

/* 远程弹窗交互 */
(function(){
  const btn = $('#btn-remote'), pop = $('#remote-pop'), inputInline = $('#remoteUrlInline'), inputHidden = $('#remoteUrl');
  function place(){ const r = btn.getBoundingClientRect(); const w = Math.min(360, Math.max(260, r.width*2)); pop.style.width=w+'px'; let left=r.left+r.width/2-w/2; left=Math.max(8, Math.min(left, innerWidth-w-8)); pop.style.left=left+'px'; pop.style.top=(r.bottom+8)+'px'; }
  function open(){ place(); pop.classList.add('show'); setTimeout(()=>inputInline?.focus(),0); }
  function close(){ pop.classList.remove('show'); }
  btn.addEventListener('click', e=>{ e.preventDefault(); pop.classList.contains('show')? close(): open(); });
  $('#remote-cancel').addEventListener('click', e=>{ e.preventDefault(); close(); });
  async function go(){ const u=(inputInline.value||'').trim(); if(!u){ setStatus('请输入 URL'); inputInline.focus(); return;} inputHidden.value=u; close(); try{ await loadRemote(); }catch{} }
  $('#remote-confirm').addEventListener('click', e=>{ e.preventDefault(); go(); });
  inputInline.addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); go(); }});
  document.addEventListener('click', e=>{ if(!btn.contains(e.target) && !pop.contains(e.target)) close(); });
  $('#btn-paste').addEventListener('click', e=>{ e.preventDefault(); pasteFromClipboard(); });
  $('#btn-clean').addEventListener('click', e=>{ e.preventDefault(); beautify(); });
  $('#btn-clear').addEventListener('click', e=>{ e.preventDefault(); clrIn(); });
})();
</script>

<script>
/* ====== GitHub 提交 & 轮询（提交后可后台恢复） ====== */
function b64ToUtf8(b64){ try{ return decodeURIComponent(escape(atob(b64))) }catch{ return atob(b64) } }

async function submitInput(){
  const path=$('#pathIn').value.trim()||'input.js';
  const api=`${repoBase()}/contents/${path}`;
  const code=$('#codeIn').value;
  if(!code){ setStatus('没有可上传的内容'); return }
  try{
    let sha=''; const head=await fetch(`${api}?ref=${$('#branch').value.trim()}&t=${nowTs()}`,{headers:ghHeaders(),cache:'no-store'});
    if(head.ok){ const j=await head.json(); sha=j.sha||''; }
    const body={ message: $('#commitMsg').value.trim()||'update via UI', content: btoa(unescape(encodeURIComponent(code))), branch: $('#branch').value.trim(), sha: sha||undefined };
    const res=await fetch(api,{ method:'PUT', headers:{ 'Content-Type':'application/json', ...ghHeaders() }, cache:'no-store', body: JSON.stringify(body) });
    const txt=await res.text(); if(!res.ok) throw new Error(res.status+' '+res.statusText+' → '+txt.slice(0,200));

    if ($('#autoResume').checked) {
      saveJobForAutoResume({
        repo: $('#repo').value.trim(),
        branch: $('#branch').value.trim(),
        whichOut: $('#whichOut').value,
        pollSec: Math.max(2, parseInt($('#pollSec').value||'5',10)),
        maxWait: Math.max(10, parseInt($('#maxWait').value||'150',10))
      });
      setStatus('提交成功 · Actions 后台执行中（可离开页面，回来自动拉取 + 智能解密）');
    } else {
      setStatus('提交成功 · 如需拉取请手动点击“开始自动轮询”');
    }
  }catch(e){ setStatus('提交失败：'+e.message); }
}

let pollingTimer=null, barTimer=null;
async function startAutoPoll(){
  try{ ghHeaders(); }catch(e){ setStatus(e.message); return }
  if(pollingTimer){ clearInterval(pollingTimer); pollingTimer=null; }
  if(barTimer){ clearInterval(barTimer); barTimer=null; }

  const which=$('#whichOut').value;
  const branch=$('#branch').value.trim();
  const api=`${repoBase()}/contents/${which}?ref=${branch}`;
  const interval=Math.max(2, parseInt($('#pollSec').value||'5',10))*1000;
  const maxWait=Math.max(10, parseInt($('#maxWait').value||'150',10))*1000;

  let lastSha=''; let waited=0;
  setStatus('正在轮询：'+which); showBar();
  barTimer=setInterval(()=>{ const b=$('#bar'); b.style.transition='none'; b.style.width='0%'; void b.offsetWidth; b.style.transition='width 5s linear'; b.style.width='100%'; },5000);

  await tryFetch();
  pollingTimer=setInterval(async ()=>{
    waited+=interval;
    const done=await tryFetch();
    if(done){ clearInterval(pollingTimer); pollingTimer=null; clearInterval(barTimer); barTimer=null; okBar(); return; }
    if(waited>=maxWait){ clearInterval(pollingTimer); pollingTimer=null; clearInterval(barTimer); barTimer=null; warnBar(); setStatus('⌛ 超时：仍未获取到 '+which); }
  }, interval);

  async function tryFetch(){
    try{
      const r=await fetch(api+'&t='+nowTs(),{headers:ghHeaders(),cache:'no-store'});
      const raw=await r.text();
      if(!r.ok){ setStatus('等待中… '+which+'（HTTP '+r.status+'）'); return false; }
      const j=JSON.parse(raw); const sha=j.sha||''; if(sha && sha===lastSha){ setStatus('等待中… '+which+'（未更新）'); return false; }
      const b64=(j.content||'').replace(/\n/g,''); const out=j.content?b64ToUtf8(b64):'';
      if(out && out.trim()){
        lastSha=sha||nowTs();
        const final = trySmartDecode(out);
        $('#codeOut').textContent = final;
        setStatus( final!==out ? '✅ 已获取并本地智能解密' : '✅ 已获取到最新 '+which );
        return true;
      }else{ setStatus('等待中… '+which+'（文件为空或未生成）'); return false; }
    }catch(e){ setStatus('等待中… '+which+'（'+e.message+'）'); return false; }
  }
}

/* Raw / 下载 */
async function loadOutputRaw(path){
  path = path || $('#whichOut').value;
  const url=`https://raw.githubusercontent.com/${$('#repo').value.trim()}/${$('#branch').value.trim()}/${path}?t=${nowTs()}`;
  try{ const r=await fetch(url,{cache:'no-store'}); const t=await r.text(); if(!r.ok) throw new Error(r.status+' '+r.statusText);
    $('#outputRaw').textContent=t; setStatus('已拉取 Raw · '+path+' · '+t.length+' 字符'); }catch(e){ $('#outputRaw').textContent='拉取失败：'+e.message+'\n'+url; setStatus('拉取失败'); }
}
function downloadOutput(){ const t=$('#codeOut').textContent||$('#outputRaw').textContent||''; const a=document.createElement('a'); a.href=URL.createObjectURL(new Blob([t],{type:'text/javascript;charset=utf-8'})); const which=$('#whichOut').value.split('/').pop()||'output.js'; a.download=which; a.click(); URL.revokeObjectURL(a.href); }
</script>

<!-- ====== AADecode 插件（前端） ====== -->
<script>
(function () {
  const module = { exports: {} };
  function extractHeader(code) {
    const i = code.search(/ﾟωﾟﾉ\s*=|ﾟдﾟ\s*=|ﾟДﾟ\s*=|ﾟΘﾟ\s*=/);
    if (i > 0) return { header: code.substring(0, i).trim(), encodedPart: code.substring(i) };
    return { header: "", encodedPart: code };
  }
  function plugin(code) {
    try {
      const { header, encodedPart } = extractHeader(code);
      if (!(encodedPart.includes("ﾟДﾟ") || encodedPart.includes("(ﾟΘﾟ)") || encodedPart.includes("ﾟωﾟﾉ") || encodedPart.includes("ﾟдﾟ"))) return null;
      let s = encodedPart.replace(") ('_')","").replace("(ﾟДﾟ) ['_'] (","return ");
      const x = new Function(s); const out = x();
      return header ? `${header}\n\n${out}` : out;
    } catch (e) { console.error("AADecode解码错误:", e); return null; }
  }
  module.exports = plugin;
  window.DecodePlugins = window.DecodePlugins || {};
  window.DecodePlugins.aadecode = { detect:c=>/ﾟωﾟﾉ|ﾟДﾟ|ﾟдﾟ|ﾟΘﾟ/.test(c), plugin:c=>{ try{ const r=module.exports(c); return r??c; }catch(e){ console.error(e); return c; } } };
})();
</script>

<!-- ====== Eval 解包（前端） ====== -->
<script>
(function () {
  const module = { exports: {} };
  function plugin(code) {
    try {
      if (!/eval\s*\(/.test(code)) return null;
      let m = code.replace(/eval\s*\(/g, "(function(x){return x;})(");
      try{
        const env = { window:{}, document:{}, navigator:{userAgent:"Mozilla/5.0"}, location:{} };
        const res = Function("window","document","navigator","location",`return ${m}`)(env.window,env.document,env.navigator,env.location);
        if (typeof res === "string") return /eval\s*\(/.test(res) ? plugin(res) : res;
        return String(res);
      }catch{
        try{ return code.replace(/eval\s*\(/g, "("); }catch{ return null; }
      }
    } catch (e) { console.error("Eval 解包错误:", e); return null; }
  }
  module.exports.plugin = (c)=>plugin(c);
  window.DecodePlugins = window.DecodePlugins || {};
  window.DecodePlugins.eval = { detect:c=>/eval\s*\(/.test(c), plugin:c=>module.exports.plugin(c) };
})();
</script>

<!-- ====== P.A.C.K.E.R 解包（前端） ====== -->
<script>
(function () {
  const P_RE = /^\s*eval\(function\s*\(\s*p\s*,\s*a\s*,\s*c\s*,\s*k\s*,\s*e\s*,\s*d\s*\)\s*\{/;
  function isPacked(code){ return P_RE.test(code); }
  function unpackOnce(source){
    if(!isPacked(source)) return null;
    const m = source.match(/eval\(function\(p,a,c,k,e,d\)\{[\s\S]*?\}\s*\(\s*(['"`])([\s\S]*?)\1\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(['"`])([\s\S]*?)\5\.split\('(\|)'\)\s*,/);
    if(!m) return null;
    const payload=m[2], radix=parseInt(m[3]), dictRaw=m[6], sep=m[7]||'|';
    const dict = dictRaw.split(sep);
    function unbase(str){ return parseInt(str, radix); }
    let p = payload.replace(/\\([\\'"`])/g,'$1')
                   .replace(/\\x([0-9A-Fa-f]{2})/g,(_,h)=>String.fromCharCode(parseInt(h,16)))
                   .replace(/\\u([0-9A-Fa-f]{4})/g,(_,h)=>String.fromCharCode(parseInt(h,16)));
    const tokenRe = /\b\w+\b/g;
    p = p.replace(tokenRe, w=>{ const idx=unbase(w); return Number.isNaN(idx)? w : (dict[idx]??w); });
    return p;
  }
  function unpackRecursive(code, max=6){
    let s=code; for(let i=0;i<max;i++){ const out=unpackOnce(s); if(out==null) break; s=String(out).trim(); }
    return s;
  }
  window.DecodePlugins = window.DecodePlugins || {};
  window.DecodePlugins.packer = { detect: c=>P_RE.test(c), plugin: c=>{ try{ const out=unpackRecursive(c); return out||c; }catch(e){ console.error('Packer 解包失败',e); return c; } } };
})();
</script>

<!-- ====== 智能解密（自动） ====== -->
<script>
function trySmartDecode(text){
  if(!$('#autoSmart').checked) return text;
  let before = String(text), changed = false, rounds = 0;
  const maxRounds = 6;
  while(rounds++ < maxRounds){
    let cur = before;
    // 顺序：Packer -> Eval -> AA
    try{ if(window.DecodePlugins?.packer?.detect(cur)){ const t = window.DecodePlugins.packer.plugin(cur); if(typeof t==='string') cur = t; } }catch{}
    try{ if(window.DecodePlugins?.eval?.detect(cur)){ const t = window.DecodePlugins.eval.plugin(cur); if(typeof t==='string') cur = t; } }catch{}
    try{ if(window.DecodePlugins?.aadecode?.detect(cur)){ const t = window.DecodePlugins.aadecode.plugin(cur); if(typeof t==='string') cur = t; } }catch{}
    if(cur === before) break;
    before = cur; changed = true;
  }
  return changed ? before : text;
}
function trySmartDecodeAndShow(src,label){
  if(!$('#autoSmart').checked) return;
  const out = trySmartDecode(src);
  if(out !== src){
    $('#codeOut').textContent = out;
    setStatus(`✅ ${label} · 本地智能解密完成`);
  }
}

/* ====== 后台恢复轮询（含智能解密） ====== */
function saveJobForAutoResume(job){
  const data = { ...job, startedAt: Date.now(), lastSha:'', etag:'', expiry: Date.now()+job.maxWait*1000+5*60*1000 };
  localStorage.setItem('oto_auto_job', JSON.stringify(data));
}
function loadJob(){ try{ const raw=localStorage.getItem('oto_auto_job'); if(!raw) return null; const j=JSON.parse(raw); if(!j || !j.expiry || Date.now()>j.expiry){ localStorage.removeItem('oto_auto_job'); return null; } return j; }catch{ return null; } }
function clearJob(){ localStorage.removeItem('oto_auto_job'); }
async function pollOutputOnce(job, state){
  const api=`https://api.github.com/repos/${job.repo}/contents/${job.whichOut}?ref=${job.branch}&t=${Date.now()}`;
  const headers={ ...ghHeaders() }; if(state.etag){ headers['If-None-Match']=state.etag; }
  const res=await fetch(api,{headers,cache:'no-store'});
  if(res.status===304){ setStatus('等待中…（未改变 304）'); return {done:false}; }
  const text=await res.text(); if(!res.ok){ setStatus(`等待中…（HTTP ${res.status}）`); return {done:false}; }
  const etag=res.headers.get('ETag')||state.etag; const j=JSON.parse(text); const sha=j.sha||''; const b64=(j.content||'').replace(/\n/g,''); const raw=j.content?b64ToUtf8(b64):'';
  if(state.sha && sha===state.sha){ setStatus('等待中…（未更新）'); return {done:false, etag, sha: state.sha}; }
  if(raw && raw.trim()){
    const final = trySmartDecode(raw);
    $('#codeOut').textContent = final;
    setStatus( final!==raw ? `✅ 本地智能解密完成 · ${final.length} 字符` : `✅ 已获取到最新 ${job.whichOut} · ${raw.length} 字符`);
    return {done:true, etag, sha};
  }
  setStatus('等待中…（文件为空或未生成）'); return {done:false, etag, sha};
}
async function autoResumeIfNeeded(){
  const job=loadJob(); if(!job) return;
  const short=Math.max(2, parseInt(job.pollSec||5,10)), long=Math.min(30, short*3);
  let waited=0, sha='', etag='';
  setStatus(`⏳ 正在恢复轮询：${job.whichOut}`); showBar();
  const b=$('#bar'); const barTimer=setInterval(()=>{ b.style.transition='none'; b.style.width='0%'; void b.offsetWidth; b.style.transition='width 5s linear'; b.style.width='100%'; },5000);
  async function tick(){
    const interval=document.hidden? long*1000 : short*1000;
    const {done, sha:newSha, etag:newEtag}=await pollOutputOnce(job,{sha,etag});
    if(newSha) sha=newSha; if(newEtag) etag=newEtag;
    if(done){ okBar(); clearInterval(timer); clearInterval(barTimer); clearJob(); return; }
    waited+=interval;
    if(waited>=job.maxWait*1000){ warnBar(); clearInterval(timer); clearInterval(barTimer); setStatus(`⌛ 超时：仍未获取到 ${job.whichOut}`); }
  }
  await tick();
  const timer=setInterval(tick, short*1000);
  document.addEventListener('visibilitychange', ()=>{ if(!document.hidden) tick(); }, {passive:true});
}
document.addEventListener('visibilitychange', ()=>{ if(!document.hidden) autoResumeIfNeeded(); }, {passive:true});
window.addEventListener('load', autoResumeIfNeeded);
</script>
</body>
</html>
