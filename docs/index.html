<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OtOjs · 解密前端（自动轮询 + 智能解密）</title>
  <link rel="stylesheet" href="style.css" />
  <!-- 强制换行，避免长行一整块 -->
  <style>
    pre{white-space:pre-wrap;word-break:break-word}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>OtOjs · 解密前端（自动轮询 + 智能解密）</h1>

    <!-- 基础配置 -->
    <div class="card">
      <div class="row">
        <div style="flex:2">
          <label>REPO</label>
          <input id="repo" value="Mikephie/OtOjs" />
        </div>
        <div>
          <label>BRANCH</label>
          <input id="branch" value="main" />
        </div>
        <div>
          <label>Token（contents:rw）</label>
          <input id="token" type="password" placeholder="ghp_..." />
        </div>
      </div>
    </div>

    <!-- 输入 -->
    <div class="card">
      <small>把待解密脚本放到 <b>input.js</b> → Actions 自动跑 → 拉回输出文件并智能解密</small>
      <div class="row compact">
        <input type="file" id="file" accept=".js,.txt,.json" />
        <button onclick="pick()">文件</button>
        <input id="remoteUrl" placeholder="https:// 原始脚本 URL（支持 github/blob 自动转 raw）" />
        <button onclick="loadRemote()">远程</button>
        <button onclick="pasteFromClipboard()">粘贴</button>
        <button class="err" onclick="clrIn()">清空</button>
      </div>
      <textarea id="codeIn" placeholder="把待解密 JS 粘贴到这里，或用上方导入"></textarea>
      <div class="row compact">
        <button class="ok" onclick="submitInput()">提交</button>
        <button class="warn" onclick="startAutoPoll()">轮询</button>
        <button onclick="beautify()">美化</button>
        <button onclick="copySel('#codeOut', this)">复制</button>
        <button class="err" onclick="clrAll()">清空全部</button>
      </div>
      <div class="options">
        <label><input type="checkbox" id="autoDecode" checked /> 自动智能解密</label>
        <label><input type="checkbox" id="autoBeautify" /> 自动美化（Prettier）</label>
        <label><input type="checkbox" id="autoResume" checked /> 后台恢复拉取</label>
      </div>
      <div id="status"><small>状态：就绪</small></div>
      <div class="bar-wrap" id="barWrap" style="display:none"><div class="bar" id="bar"></div></div>
      <pre id="codeOut" placeholder="结果将显示在这里"></pre>
    </div>

    <!-- 输出 -->
    <div class="card">
      <div class="row compact">
        <button onclick="loadOutputRaw('output/output.js')">拉取 output.js</button>
        <button onclick="loadOutputRaw('output/output.deob2.js')">拉取 deob2.js</button>
        <button onclick="copySel('#outputRaw', this)">复制结果</button>
        <button onclick="downloadOutput()">下载</button>
      </div>
      <pre id="outputRaw"></pre>
    </div>
  </div>

  <!-- 先加载你原有逻辑 -->
  <script src="decode-all.js"></script>
  <script src="app.js"></script>

  <!-- 再加载 wrapper（覆盖同名插件） -->
  <script src="main/src/wrapper/aadecode-wrapper.js"></script>
  <script src="main/src/wrapper/eval-wrapper.js"></script>

  <!-- 强制只用 eval + aadecode，并冻结管道，避免被覆盖 -->
  <script>
  (function () {
    // 兜底：两个 wrapper 若缺失，直接挂个空实现防止报错
    window.DecodePlugins = window.DecodePlugins || {};
    if (!window.DecodePlugins.eval) {
      window.DecodePlugins.eval = { detect: ()=>false, plugin: s=>null };
    }
    if (!window.DecodePlugins.aadecode) {
      window.DecodePlugins.aadecode = { detect: ()=>false, plugin: s=>null };
    }

    // 白名单：仅保留 eval / aadecode 两个插件
    Object.keys(window.DecodePlugins).forEach(k=>{
      if (k!=="eval" && k!=="aadecode") delete window.DecodePlugins[k];
    });

    // 轻量分行兜底（不依赖 Prettier）
    function simpleFormat(src) {
      try {
        let out = "", indent = 0;
        const lines = String(src)
          .replace(/\r/g, "")
          .replace(/;/g, ";\n")
          .replace(/\{/g, "{\n")
          .replace(/\}/g, "\n}\n")
          .split("\n");
        for (let raw of lines) {
          let line = raw.trim();
          if (!line) continue;
          if (line.startsWith("}")) indent = Math.max(0, indent - 1);
          out += "  ".repeat(indent) + line + "\n";
          if (line.endsWith("{")) indent++;
        }
        return out.trim() + "\n";
      } catch { return String(src); }
    }

    // 新管道（只跑 eval -> aadecode，多轮剥皮，有限次避免卡死）
    function pipeline(code) {
      const ORDER = ["eval","aadecode"];
      let out = String(code);
      let changed = true, rounds = 0;
      while (changed && rounds < 15) {
        changed = false; rounds++;
        for (const key of ORDER) {
          const p = window.DecodePlugins[key];
          if (!p || typeof p.detect!=="function" || typeof p.plugin!=="function") continue;
          try {
            if (p.detect(out)) {
              const res = p.plugin(out);
              if (typeof res === "string" && res && res !== out) {
                out = res;
                changed = true;
                break; // 成功一次，进入下一轮
              }
            }
          } catch(_) {}
        }
      }
      return simpleFormat(out);
    }

    // 强制覆盖并冻结，防止 app.js 之后再改
    try {
      Object.defineProperty(window, 'smartDecodePipeline', {
        configurable: true,
        writable: false,
        value: pipeline
      });
    } catch {
      // 某些环境不允许冻结就直接赋值
      window.smartDecodePipeline = pipeline;
    }
  })();
  </script>

  <!-- 复制按钮（独立，不依赖 app.js） -->
  <script>
    async function copySel(sel, btn){
      try{
        const el = document.querySelector(sel);
        const t = el ? (el.value ?? el.textContent ?? "") : "";
        if (navigator.clipboard?.writeText) {
          await navigator.clipboard.writeText(t);
        } else {
          const ta = document.createElement("textarea");
          ta.value = t; document.body.appendChild(ta);
          ta.select(); document.execCommand("copy"); ta.remove();
        }
        const old = btn.textContent;
        btn.textContent = "✅ 已复制";
        setTimeout(()=> btn.textContent = old, 1200);
      }catch(e){
        alert("复制失败：" + e.message);
      }
    }
  </script>

  <!-- 展示层：把 \"\\n\" 展开成真换行，仅影响显示 -->
  <script>
    function expandEscapedNewlines(s){
      if (typeof s !== "string") return s;
      if (!/\\n|\\r\\n/.test(s)) return s;
      try {
        const wrapped = '"' + s.replace(/\\/g,'\\\\').replace(/"/g,'\\"') + '"';
        return JSON.parse(wrapped);
      } catch {
        return s.replace(/\\r\\n/g,'\n').replace(/\\n/g,'\n').replace(/\\t/g,'\t');
      }
    }
    function softBreak(s){
      if (typeof s !== "string") return s;
      if ((s.match(/\n/g)||[]).length >= 5) return s;
      return s
        .replace(/;\s*(?!\n)/g,';\n')
        .replace(/\}\s*(?!\n)/g,'}\n')
        .replace(/\)\s*;\s*(?!\n)/g,');\n');
    }
    function reflowPre(el){
      const raw = el.textContent || '';
      const expanded = expandEscapedNewlines(raw);
      const out = softBreak(expanded);
      if (out !== raw) el.textContent = out;
    }
    const _mo1 = new MutationObserver(()=> reflowPre(document.getElementById('codeOut')));
    const _mo2 = new MutationObserver(()=> reflowPre(document.getElementById('outputRaw')));
    window.addEventListener('load', ()=>{
      const a=document.getElementById('codeOut'), b=document.getElementById('outputRaw');
      if(a) _mo1.observe(a,{childList:true,subtree:true,characterData:true});
      if(b) _mo2.observe(b,{childList:true,subtree:true,characterData:true});
    });
  </script>

  <!-- 可选：如需本地 Prettier，自行按需引入（此页面不依赖） -->
  <!--
  <script src="prettier.min.js"></script>
  <script src="parser-babel.min.js"></script>
  -->
</body>
</html>
