<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OtOjs · 解密前端（自动轮询 + 智能解密）</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    /* 让结果区域自然换行，避免挤成一行 */
    pre { white-space: pre-wrap; word-break: break-word; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>OtOjs · 解密前端（自动轮询 + 智能解密）</h1>

    <!-- 基础配置 -->
    <div class="card">
      <div class="row">
        <div style="flex:2">
          <label>REPO</label>
          <input id="repo" value="Mikephie/OtOjs" />
        </div>
        <div>
          <label>BRANCH</label>
          <input id="branch" value="main" />
        </div>
        <div>
          <label>Token（contents:rw）</label>
          <input id="token" type="password" placeholder="ghp_..." />
        </div>
      </div>
    </div>

    <!-- 输入 -->
    <div class="card">
      <small>把待解密脚本放到 <b>input.js</b> → Actions 自动跑 → 拉回输出文件并智能解密</small>
      <div class="row compact">
        <input type="file" id="file" accept=".js,.txt,.json" />
        <button onclick="pick()">文件</button>
        <input id="remoteUrl" placeholder="https:// 原始脚本 URL（支持 github/blob 自动转 raw）" />
        <button onclick="loadRemote()">远程</button>
        <button onclick="pasteFromClipboard()">粘贴</button>
        <button class="err" onclick="clrIn()">清空</button>
      </div>
      <textarea id="codeIn" placeholder="把待解密 JS 粘贴到这里，或用上方导入"></textarea>
      <div class="row compact">
        <button class="ok" onclick="submitInput()">提交</button>
        <button class="warn" onclick="startAutoPoll()">轮询</button>
        <button onclick="beautify()">美化</button>
        <button onclick="copySel('#codeOut', this)">复制</button>
        <button class="err" onclick="clrAll()">清空全部</button>
      </div>
      <div class="options">
        <label><input type="checkbox" id="autoDecode" checked /> 自动智能解密</label>
        <label><input type="checkbox" id="autoBeautify" /> 自动美化（Prettier）</label>
        <label><input type="checkbox" id="autoResume" checked /> 后台恢复拉取</label>
      </div>
      <div id="status"><small>状态：就绪</small></div>
      <div class="bar-wrap" id="barWrap" style="display:none"><div class="bar" id="bar"></div></div>
      <pre id="codeOut" placeholder="结果将显示在这里"></pre>
    </div>

    <!-- 输出（Raw） -->
    <div class="card">
      <div class="row compact">
        <button onclick="loadOutputRaw('output/output.js')">拉取 output.js</button>
        <button onclick="loadOutputRaw('output/output.deob2.js')">拉取 deob2.js</button>
        <button onclick="copySel('#outputRaw', this)">复制结果</button>
        <button onclick="downloadOutput()">下载</button>
      </div>
      <pre id="outputRaw"></pre>
    </div>
  </div>

  <!-- 可选：Prettier（用于“解密之后”的美化；加载失败不影响秒解） -->
  <script src="https://unpkg.com/prettier@3.2.5/standalone.js"></script>
  <script src="https://unpkg.com/prettier@3.2.5/plugins/babel.js"></script>
  <script src="https://unpkg.com/prettier@3.2.5/plugins/estree.js"></script>

  <!-- 顺序非常重要：先插件，再主逻辑（保持你的文件名） -->
  <script src="decode-all.js"></script>
  <script src="app.js"></script>

  <!-- 全局复制函数（移动端可用） -->
  <script>
    async function copySel(sel, btn){
      try{
        const el = document.querySelector(sel);
        const t = el ? (el.value ?? el.textContent ?? '') : '';
        if (navigator.clipboard?.writeText) {
          await navigator.clipboard.writeText(t);
        } else {
          const ta=document.createElement('textarea');
          ta.value=t; document.body.appendChild(ta);
          ta.select(); document.execCommand('copy'); ta.remove();
        }
        const old=btn.textContent; btn.textContent='✅ 已复制';
        setTimeout(()=>btn.textContent=old,1200);
      }catch(e){
        alert('复制失败：'+e.message);
      }
    }
  </script>

  <!-- “先解密，后美化”的秒解监视器（不会改动原始输入） -->
  <script>
    // 封装：立即执行一次“解密→可选美化→显示”
    async function decodeAndRender(src){
      const outEl = document.querySelector('#codeOut');
      const statusEl = document.getElementById('status');
      if (!outEl) return;

      // 1) 先解密（不对原文做任何分行/替换）
      let decoded = null;
      if (document.querySelector('#autoDecode')?.checked && typeof window.smartDecodePipeline === 'function') {
        try { decoded = await window.smartDecodePipeline(String(src)); } catch {}
      }

      // 2) 选择展示内容：能解出来就展示解密结果，否则展示原文
      let shown = (typeof decoded === 'string' && decoded) ? decoded : String(src);
      let pretty = shown;

      // 3) 仅对“已选中的展示内容”做 Prettier（不会影响后续再次解密）
      if (document.querySelector('#autoBeautify')?.checked &&
          window.prettier && window.prettierPlugins &&
          (window.prettierPlugins.babel || window.prettierPlugins.estree)) {
        try {
          const plugins = [window.prettierPlugins.babel, window.prettierPlugins.estree].filter(Boolean);
          pretty = window.prettier.format(shown, { parser: 'babel', plugins });
        } catch { pretty = shown; }
      }

      outEl.textContent = pretty;
      statusEl.innerHTML = '<small>' +
        ((decoded && decoded!==src) ? '✅ 已解密' : 'ℹ️ 已载入（无可解层）') +
        (pretty!==shown ? ' · 已美化' : '') +
        '</small>';
    }

    // 监视 #codeIn 内容变化：文件/远程/粘贴/手改都会触发
    (function(){
      const input = document.querySelector('#codeIn');
      if (!input) return;
      let last = input.value;
      setInterval(async ()=>{
        const cur = input.value;
        if (cur !== last) {
          last = cur;
          if (cur.trim()) await decodeAndRender(cur);
        }
      }, 350);
    })();

    // 文件导入快捷：与你现有 app.js 的 pick()/loadRemote()/pasteFromClipboard() 兼容
    document.getElementById('file')?.addEventListener('change', async e=>{
      const f=e.target.files?.[0]; if(!f) return;
      const txt=await f.text(); document.querySelector('#codeIn').value=txt;
      await decodeAndRender(txt);
    });
  </script>
</body>
</html>