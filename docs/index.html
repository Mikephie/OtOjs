<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OtOjs · 解密前端（自动轮询 + 智能解密）</title>
  <link rel="stylesheet" href="style.css" />
  <!-- 兜底换行，避免长行挤成一行；如被外部样式覆盖，下面两个 <pre> 也会用内联样式强制 -->
  <style>
    pre{white-space:pre-wrap;word-break:break-word}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>OtOjs · 解密前端（自动轮询 + 智能解密）</h1>

    <!-- 基础配置 -->
    <div class="card">
      <div class="row">
        <div style="flex:2">
          <label>REPO</label>
          <input id="repo" value="Mikephie/OtOjs" />
        </div>
        <div>
          <label>BRANCH</label>
          <input id="branch" value="main" />
        </div>
        <div>
          <label>Token（contents:rw）</label>
          <input id="token" type="password" placeholder="ghp_..." />
        </div>
      </div>
    </div>

    <!-- 输入 -->
    <div class="card">
      <small>把待解密脚本放到 <b>input.js</b> → Actions 自动跑 → 拉回输出文件并智能解密</small>
      <div class="row compact">
        <input type="file" id="file" accept=".js,.txt,.json" />
        <button onclick="pick()">文件</button>
        <input id="remoteUrl" placeholder="https:// 原始脚本 URL（支持 github/blob 自动转 raw）" />
        <button onclick="loadRemote()">远程</button>
        <button onclick="pasteFromClipboard()">粘贴</button>
        <button class="err" onclick="clrIn()">清空</button>
      </div>
      <textarea id="codeIn" placeholder="把待解密 JS 粘贴到这里，或用上方导入"></textarea>
      <div class="row compact">
        <button class="ok" onclick="submitInput()">提交</button>
        <button class="warn" onclick="startAutoPoll()">轮询</button>
        <button onclick="beautify()">美化</button>
        <button onclick="copySel('#codeOut', this)">复制</button>
        <button class="err" onclick="clrAll()">清空全部</button>
      </div>
      <div class="options">
        <label><input type="checkbox" id="autoDecode" checked /> 自动智能解密</label>
        <label><input type="checkbox" id="autoBeautify" /> 自动美化（Prettier）</label>
        <label><input type="checkbox" id="autoResume" checked /> 后台恢复拉取</label>
      </div>
      <div id="status"><small>状态：就绪</small></div>
      <div class="bar-wrap" id="barWrap" style="display:none"><div class="bar" id="bar"></div></div>
      <!-- 用内联样式强制换行显示 -->
      <pre id="codeOut" style="white-space:pre-wrap;word-break:break-word" placeholder="结果将显示在这里"></pre>
    </div>

    <!-- 输出 -->
    <div class="card">
      <div class="row compact">
        <button onclick="loadOutputRaw('output/output.js')">拉取 output.js</button>
        <button onclick="loadOutputRaw('output/output.deob2.js')">拉取 deob2.js</button>
        <button onclick="copySel('#outputRaw', this)">复制结果</button>
        <button onclick="downloadOutput()">下载</button>
      </div>
      <!-- 用内联样式强制换行显示 -->
      <pre id="outputRaw" style="white-space:pre-wrap;word-break:break-word"></pre>
    </div>
  </div>

  <!-- 顺序非常重要：先插件，再主逻辑 -->
  <script src="decode-all.js"></script>
  <script src="app.js"></script>

  <!-- 复制按钮：内联全局函数，避免依赖 app.js 暴露 -->
  <script>
    async function copySel(sel, btn){
      try{
        const el = document.querySelector(sel);
        const t = el ? (el.value ?? el.textContent ?? '') : '';
        if (navigator.clipboard?.writeText) {
          await navigator.clipboard.writeText(t);
        } else {
          const ta = document.createElement('textarea');
          ta.value = t; document.body.appendChild(ta);
          ta.select(); document.execCommand('copy'); ta.remove();
        }
        const old = btn.textContent; btn.textContent = '✅ 已复制';
        setTimeout(()=> btn.textContent = old, 1200);
      }catch(e){
        alert('复制失败：' + e.message);
      }
    }
  </script>

  <!-- 仅对“已输出的明文”做温和分行（不触碰原始输入，不影响解密） -->
  <script>
    // 1) 展开 \"\\n\\t 这类转义为真实字符（尽量不破坏内容）
    function expandEscaped(s){
      if (typeof s !== 'string') return s;
      // 没有明显转义符就不处理
      if (!/\\[nrvt]/.test(s)) return s;
      try {
        // 用 JSON 安全方式展开，避免误替换
        const wrapped = '"' + s.replace(/\\/g,'\\\\').replace(/"/g,'\\"') + '"';
        return JSON.parse(wrapped);
      } catch {
        return s
          .replace(/\\r\\n/g, '\n')
          .replace(/\\n/g, '\n')
          .replace(/\\t/g, '\t')
          .replace(/\\r/g, '\r')
          .replace(/\\v/g, '\v');
      }
    }

    // 2) 温和断行：覆盖更全的断点，但尽量不动字符串/模板区
    function gentleBreak(code){
      if (typeof code !== 'string') return code;
      // 已经比较“宽松”的就不再处理
      if ((code.match(/\n/g)||[]).length >= 8) return code;

      // 粗分块：以引号/反引号为界，奇偶段为“代码段/字面量段”
      const parts = [];
      let i=0, cur='', mode='code', quote=null, esc=false;
      while(i < code.length){
        const ch = code[i];

        if (mode==='code'){
          if (ch === '"' || ch === "'" || ch === '`'){
            // 切换到字面量段
            parts.push({type:'code', text:cur}); cur=''; mode='lit'; quote=ch; esc=false; cur+=ch;
          } else {
            cur += ch;
          }
          i++; continue;
        }

        // 在字面量段中，直到遇到未转义的同类引号才结束
        if (mode==='lit'){
          cur += ch;
          if (esc){ esc=false; i++; continue; }
          if (ch === '\\'){ esc=true; i++; continue; }
          if (ch === quote){ // 结束字面量
            parts.push({type:'lit', text:cur}); cur=''; mode='code'; quote=null;
          }
          i++; continue;
        }
      }
      if (cur) parts.push({type: mode, text: cur});

      // 只处理“代码段”，字面量原样保留
      const broken = parts.map(seg=>{
        if (seg.type !== 'code') return seg.text;

        let s = seg.text;

        // 常见结构后的断行
        s = s
          .replace(/;\s*(?!\n)/g, ';\n')           // ; 结束
          .replace(/\}\s*(?!\n)/g, '}\n')          // } 结束
          .replace(/\)\s*;\s*(?!\n)/g, ');\n')     // ); 结束
          .replace(/,\s*(?!\n)/g, ',\n')           // 逗号分隔（对象/数组/形参列表）
          .replace(/:\s*(?=[{\[])/g, ':\n')        // 冒号后是对象/数组，断一行
          .replace(/\b(else|catch|finally)\b\s*(?=\{|$begin:math:text$)/g, '\\n$1 ') // 分支关键字前断行
          .replace(/\\b(if|for|while|switch|with)\\s*\\(/g, '\\n$1(')    // 控制结构前断行
          .replace(/\\b(do)\\b\\s*(?=\\{)/g, '\\n$1 ')                    // do {...}
          .replace(/\\b(return|throw)\\b\\s+(?=[^;\\n])/g, '$1 ')        // 保留 return/throw 后空格
          .replace(/$end:math:text$\s*=>\s*\{/g, ')\n=> {')                      // 箭头函数
          .replace(/\bfunction\b\s*(\w*)\s*$begin:math:text$/g, '\\nfunction $1('); // function

        // 连续右括号堆叠时给点呼吸位
        s = s.replace(/$end:math:text$\s*\)\s*\)\s*/g, ')))\n')
             .replace(/\]\s*\]\s*\]\s*/g, ']]]\n');

        // 多个空格合并为一个（不动换行）
        s = s.replace(/[ \t]{2,}/g, ' ');

        return s;
      }).join('');

      // 去掉多余空行（最多保留 2 行）
      return broken.replace(/\n{3,}/g, '\n\n');
    }

    // 3) 总流程：展开转义 → 温和断行（仅对 <pre> 内现有文本）
    function reflowPre(el){
      if (!el) return;
      const raw = el.textContent || '';
      const expanded = expandEscaped(raw);
      const out = gentleBreak(expanded);
      if (out !== raw) el.textContent = out;
    }

    // 4) 监听两个 <pre> 的内容变化，自动“只对已输出内容”做分行
    const _mo1 = new MutationObserver(()=> reflowPre(document.getElementById('codeOut')));
    const _mo2 = new MutationObserver(()=> reflowPre(document.getElementById('outputRaw')));
    window.addEventListener('load', ()=>{
      const a=document.getElementById('codeOut'), b=document.getElementById('outputRaw');
      if(a) _mo1.observe(a,{childList:true,subtree:true,characterData:true});
      if(b) _mo2.observe(b,{childList:true,subtree:true,characterData:true});
    });
  </script>
</body>
</html>