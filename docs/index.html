<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OtOjs · 解密前端（自动轮询 + 智能解密）</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    /* 保证结果区域一定可读 */
    pre{
      white-space: pre-wrap;
      word-break: break-word;
      overflow-wrap: anywhere;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>OtOjs · 解密前端（自动轮询 + 智能解密）</h1>

    <!-- 基础配置 -->
    <div class="card">
      <div class="row">
        <div style="flex:2">
          <label>REPO</label>
          <input id="repo" value="Mikephie/OtOjs" />
        </div>
        <div>
          <label>BRANCH</label>
          <input id="branch" value="main" />
        </div>
        <div>
          <label>Token（contents:rw）</label>
          <input id="token" type="password" placeholder="ghp_..." />
        </div>
      </div>
    </div>

    <!-- 输入 -->
    <div class="card">
      <small>把待解密脚本放到 <b>input.js</b> → Actions 自动跑 → 拉回输出文件并智能解密</small>
      <div class="row compact">
        <input type="file" id="file" accept=".js,.txt,.json" />
        <button onclick="pick()">文件</button>
        <input id="remoteUrl" placeholder="https:// 原始脚本 URL（支持 github/blob 自动转 raw）" />
        <button onclick="loadRemote()">远程</button>
        <button onclick="pasteFromClipboard()">粘贴</button>
        <button class="err" onclick="clrIn()">清空</button>
      </div>
      <textarea id="codeIn" placeholder="把待解密 JS 粘贴到这里，或用上方导入"></textarea>
      <div class="row compact">
        <button class="ok" onclick="submitInput()">提交</button>
        <button class="warn" onclick="startAutoPoll()">轮询</button>
        <button onclick="beautify()">美化</button>
        <button onclick="copySel('#codeOut', this)">复制</button>
        <button class="err" onclick="clrAll()">清空全部</button>
      </div>
      <div class="options">
        <label><input type="checkbox" id="autoDecode" checked /> 自动智能解密</label>
        <label><input type="checkbox" id="autoBeautify" /> 自动美化（Prettier）</label>
        <label><input type="checkbox" id="autoResume" checked /> 后台恢复拉取</label>
      </div>
      <div id="status"><small>状态：就绪</small></div>
      <div class="bar-wrap" id="barWrap" style="display:none"><div class="bar" id="bar"></div></div>

      <!-- 结果面板 -->
      <pre id="codeOut" style="white-space:pre-wrap;word-break:break-word" placeholder="结果将显示在这里"></pre>
    </div>

    <!-- 输出（Raw） -->
    <div class="card">
      <div class="row compact">
        <button onclick="loadOutputRaw('output/output.js')">拉取 output.js</button>
        <button onclick="loadOutputRaw('output/output.deob2.js')">拉取 deob2.js</button>
        <button onclick="copySel('#outputRaw', this)">复制结果</button>
        <button onclick="downloadOutput()">下载</button>
      </div>
      <pre id="outputRaw" style="white-space:pre-wrap;word-break:break-word"></pre>
    </div>
  </div>

  <!-- 保持原有顺序 -->
  <script src="decode-all.js"></script>
  <script src="app.js"></script>

  <!-- 复制按钮（移动端兜底） -->
  <script>
    async function copySel(sel, btn){
      try{
        const el = document.querySelector(sel);
        const t = el ? (el.value ?? el.textContent ?? '') : '';
        if (navigator.clipboard?.writeText) {
          await navigator.clipboard.writeText(t);
        } else {
          const ta = document.createElement('textarea');
          ta.value = t; document.body.appendChild(ta);
          ta.select(); document.execCommand('copy'); ta.remove();
        }
        const old = btn.textContent; btn.textContent = '✅ 已复制';
        setTimeout(()=> btn.textContent = old, 1200);
      }catch(e){
        alert('复制失败：' + e.message);
      }
    }
  </script>

  <!-- 显示层“简易美化器”：展开 \n，并按 { } ; , 缩进分行（避开字符串/注释/正则） -->
  <script>
    // 把 \" \\n 这些转义展开为真实字符
    function expandEscaped(s){
      if (typeof s !== 'string') return s;
      if (!/\\[nrt"\\]/.test(s)) return s;
      try {
        const wrapped = '"' + s.replace(/\\/g,'\\\\').replace(/"/g,'\\"') + '"';
        return JSON.parse(wrapped);
      } catch {
        return s.replace(/\\r\\n/g,'\n').replace(/\\n/g,'\n').replace(/\\t/g,'\t').replace(/\\r/g,'\r').replace(/\\"/g,'"').replace(/\\\\/g,'\\');
      }
    }

    // 轻量格式化：仅做“可读”分行/缩进，不做语法重排
    function simplePretty(src){
      const s = String(src);
      const n = s.length;
      let out = '';
      let indent = 0, i = 0;

      const IND = '  '; // 两空格缩进
      let inStr = false, strQ = '', esc = false;
      let inSL = false, inML = false;
      let inReg = false;
      let lastNonSpace = '';

      function add(c){ out += c; if (!/\s/.test(c)) lastNonSpace = c; }

      while (i < n){
        let c = s[i], nxt = s[i+1];

        // 单行注释
        if (!inStr && !inML && !inSL && !inReg && c === '/' && nxt === '/'){
          inSL = true; add(c); i++; add(nxt); i++; continue;
        }
        if (inSL){
          add(c);
          if (c === '\n'){ inSL = false; }
          i++; continue;
        }

        // 多行注释
        if (!inStr && !inML && !inReg && c === '/' && nxt === '*'){
          inML = true; add(c); i++; add(nxt); i++; continue;
        }
        if (inML){
          add(c);
          if (c === '*' && nxt === '/'){ i++; add('/'); inML = false; }
          i++; continue;
        }

        // 字符串
        if (!inStr && !inReg && (c === '"' || c === "'" || c === '`')){
          inStr = true; strQ = c; esc = false; add(c); i++; continue;
        }
        if (inStr){
          add(c);
          if (esc){ esc = false; }
          else if (c === '\\'){ esc = true; }
          else if (c === strQ){ inStr = false; }
          i++; continue;
        }

        // 正则字面量（非常简化：在可作为运算符/起始后出现 / 则视为正则）
        const canStartRegex = /[({[=:+\-!*?,;<>%^&|~]\s*$/.test(out) || out === '';
        if (!inReg && c === '/' && nxt && nxt !== '/' && nxt !== '*'){
          if (canStartRegex){ inReg = true; add(c); i++; continue; }
        }
        if (inReg){
          add(c);
          if (c === '\\'){ // 跳过转义
            if (i+1 < n){ add(s[i+1]); i += 2; continue; }
          }
          if (c === '/'){ // 读修饰符
            i++;
            while (i < n && /[a-z]/i.test(s[i])) { add(s[i]); i++; }
            inReg = false; continue;
          }
          i++; continue;
        }

        // 结构化分行/缩进（非字符串/注释/正则环境）
        if (c === '{'){
          add('{');
          indent++;
          out += '\n' + IND.repeat(indent);
          i++; continue;
        }
        if (c === '}'){
          indent = Math.max(0, indent - 1);
          // 如果前面不是换行，先换行再补右括号
          if (!/\n\s*$/.test(out)) out += '\n';
          out += IND.repeat(indent) + '}';
          // 若下一个是逗号/分号，延后处理；否则换行
          if (s[i+1] !== ',' && s[i+1] !== ';') out += '\n' + IND.repeat(indent);
          i++; continue;
        }
        if (c === ';'){
          add(';');
          out += '\n' + IND.repeat(indent);
          i++; continue;
        }
        if (c === ','){
          add(',');
          // 在对象/数组内更友好的断行
          out += '\n' + IND.repeat(indent);
          i++; continue;
        }
        if (c === ')'){
          add(')');
          // 常见模式："){" 交给下一轮的 "{"
          i++; continue;
        }

        // 关键字后适度加空格
        if (/\s/.test(c)){
          // 压缩连续空白为单个空格/保持换行
          if (c === '\n'){
            out += '\n' + IND.repeat(indent);
          }else{
            if (!/\s$/.test(out)) out += ' ';
          }
          i++; continue;
        }

        add(c);
        i++;
      }

      // 清理多余空行
      out = out.replace(/\n{3,}/g, '\n\n');
      return out.trimEnd();
    }

    // 统一“显示层”处理：展开转义 → 分行缩进
    function prettyForDisplay(raw){
      const a = expandEscaped(String(raw));
      return simplePretty(a);
    }

    // 每当 app.js 写入结果时，重排显示（不影响原始字符串/复制/下载）
    function reflowPre(el){
      if (!el) return;
      const raw = el.textContent || '';
      const pretty = prettyForDisplay(raw);
      if (pretty !== raw) el.textContent = pretty;
    }

    const mo1 = new MutationObserver(()=> reflowPre(document.getElementById('codeOut')));
    const mo2 = new MutationObserver(()=> reflowPre(document.getElementById('outputRaw')));
    window.addEventListener('load', ()=>{
      const a=document.getElementById('codeOut'), b=document.getElementById('outputRaw');
      if (a) mo1.observe(a,{childList:true,subtree:true,characterData:true});
      if (b) mo2.observe(b,{childList:true,subtree:true,characterData:true});
      reflowPre(a); reflowPre(b);
    });
  </script>
</body>
</html>
