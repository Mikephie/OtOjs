<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OtOjs · 解密前端（自动轮询 + 智能解密）</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="wrap">
    <h1>OtOjs · 解密前端（自动轮询 + 智能解密）</h1>

    <!-- 基础配置 -->
    <div class="card">
      <div class="row">
        <div style="flex:2">
          <label>REPO</label>
          <input id="repo" value="Mikephie/OtOjs" />
        </div>
        <div>
          <label>BRANCH</label>
          <input id="branch" value="main" />
        </div>
        <div>
          <label>Token（contents:rw）</label>
          <input id="token" type="password" placeholder="ghp_..." />
        </div>
      </div>
    </div>

    <!-- 输入 -->
    <div class="card">
      <small>把待解密脚本放到 <b>input.js</b> → Actions 自动跑 → 拉回输出文件并智能解密</small>
      <div class="row compact">
        <input type="file" id="file" accept=".js,.txt,.json" />
        <button onclick="pick()">文件</button>
        <input id="remoteUrl" placeholder="https:// 原始脚本 URL（支持 github/blob 自动转 raw）" />
        <button onclick="loadRemote()">远程</button>
        <button onclick="pasteFromClipboard()">粘贴</button>
        <button class="err" onclick="clrIn()">清空</button>
      </div>
      <textarea id="codeIn" placeholder="把待解密 JS 粘贴到这里，或用上方导入"></textarea>
      <div class="row compact">
        <button class="ok" onclick="submitInput()">提交</button>
        <button class="warn" onclick="startAutoPoll()">轮询</button>
        <button onclick="beautify()">美化</button>
        <button onclick="copySel('#codeOut', this)">复制</button>
        <button class="err" onclick="clrAll()">清空全部</button>
      </div>
      <div class="options">
        <label><input type="checkbox" id="autoDecode" checked /> 自动智能解密</label>
        <label><input type="checkbox" id="autoBeautify" checked /> 自动美化（Prettier）</label>
        <label><input type="checkbox" id="autoResume" checked /> 后台恢复拉取</label>
      </div>
      <div id="status"><small>状态：就绪</small></div>
      <div class="bar-wrap" id="barWrap" style="display:none"><div class="bar" id="bar"></div></div>
      <pre id="codeOut" title="结果将显示在这里"></pre>
    </div>

    <!-- 输出 -->
    <div class="card">
      <div class="row compact">
        <button onclick="loadOutputRaw('output/output.js')">拉取 output.js</button>
        <button onclick="loadOutputRaw('output/output.deob2.js')">拉取 deob2.js</button>
        <button onclick="copySel('#outputRaw', this)">复制结果</button>
        <button onclick="downloadOutput()">下载</button>
      </div>
      <pre id="outputRaw" title="Raw 输出文件内容"></pre>
    </div>
  </div>

  <!-- Prettier 依赖（含 estree，避免 AST “estree” 报错）-->
  <script src="https://unpkg.com/prettier@3.2.5/standalone.js"></script>
  <script src="https://unpkg.com/prettier@3.2.5/plugins/babel.js"></script>
  <script src="https://unpkg.com/prettier@3.2.5/plugins/estree.js"></script>

  <!-- 顺序非常重要：先插件，再主逻辑 -->
  <script src="decode-all.js"></script>
  <script src="app.js"></script>

  <!-- 修复复制 + 强制挂载“自动秒解”钩子（不改 app.js，仅补钩） -->
  <script>
    // --- 复制按钮：不依赖 app.js，全局可用 ---
    async function copySel(sel, btn) {
      try {
        const el = document.querySelector(sel);
        const t = el ? (el.value ?? el.textContent ?? '') : '';
        if (navigator.clipboard?.writeText) {
          await navigator.clipboard.writeText(t);
        } else {
          const ta = document.createElement('textarea');
          ta.value = t; document.body.appendChild(ta); ta.select();
          document.execCommand('copy'); ta.remove();
        }
        const old = btn.textContent; btn.textContent = '✅ 已复制';
        setTimeout(() => btn.textContent = old, 1200);
      } catch (e) { alert('复制失败：' + e.message); }
    }

    // --- Prettier 工具 ---
    function prettierPluginsArr() {
      if (Array.isArray(window.prettierPlugins)) return window.prettierPlugins;
      const arr = [];
      if (window.prettierPlugins?.babel) arr.push(window.prettierPlugins.babel);
      if (window.prettierPlugins?.estree) arr.push(window.prettierPlugins.estree);
      return arr;
    }
    async function prettyIfNeeded(code) {
      if (!document.querySelector('#autoBeautify').checked) return code;
      try {
        return await window.prettier.format(String(code), {
          parser: 'babel',
          plugins: prettierPluginsArr()
        });
      } catch { return code; }
    }

    // --- 智能秒解：直接调用 decode-all.js 暴露的 smartDecodePipeline ---
    async function runSmartDecode(src) {
      if (!document.querySelector('#autoDecode').checked) return null;
      if (typeof window.smartDecodePipeline !== 'function') return null;
      try { return await window.smartDecodePipeline(String(src)); }
      catch { return null; }
    }

    // --- 把“秒解 +（可选）美化”写回输出框 ---
    async function decodeAndShow(src, label) {
      const decoded = await runSmartDecode(src);
      if (!decoded) return false;
      const pretty = await prettyIfNeeded(decoded);
      document.querySelector('#codeOut').textContent = pretty;
      const s = (pretty !== decoded) ? '（已美化）' : '';
      const st = document.querySelector('#status'); if (st) st.innerHTML = `<small>状态：✅ ${label} · 已智能解密${s}</small>`;
      return true;
    }

    // --- 绑定事件（不改你的 app.js；两边都能触发） ---
    function debounce(fn, t=300){ let id; return (...a)=>{ clearTimeout(id); id=setTimeout(()=>fn(...a),t); }; }

    // 1) 选择文件后：读文本 → 秒解 →（可选）美化
    document.getElementById('file').addEventListener('change', async (e) => {
      const f = e.target.files?.[0]; if (!f) return;
      const txt = await f.text();
      // app.js 自己也会触发；这里再补一层，以确保“秒解一定会跑”
      decodeAndShow(txt, '本地文件');
    });

    // 2) 手动粘贴/编辑：防抖 400ms 自动尝试秒解
    document.getElementById('codeIn').addEventListener('input', debounce(async () => {
      const v = document.getElementById('codeIn').value;
      if (!v.trim()) return;
      decodeAndShow(v, '输入');
    }, 400));

    // 3) 拉取 Raw 后自动尝试秒解（监听 #outputRaw 的变化）
    //    如果你的 app.js 在 loadOutputRaw 里已经会 decode，就当双保险。
    const rawEl = document.getElementById('outputRaw');
    const mo = new MutationObserver(debounce(async () => {
      const raw = rawEl.textContent || '';
      if (raw.trim()) decodeAndShow(raw, 'Raw');
    }, 300));
    mo.observe(rawEl, { childList: true, characterData: true, subtree: true });

    // 4) 初始：如果 textarea 里本来就有内容，且勾选了“自动智能解密”，也尝试跑一次
    window.addEventListener('load', () => {
      const init = document.getElementById('codeIn').value.trim();
      if (init) decodeAndShow(init, '初始内容');
    });
  </script>
</body>
</html>